### 개요
---
- 빠른 사이트는 더 좋은 사용자 경험을 제공합니다.
- 사용자는 로드가 빠르고 상호작용이 원활한 컨텐츠로 이루어진 웹 경험을 원합니다.
<br>

### 파싱과 렌더링
---
- **파싱**
    - 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽고 실행하기 위해 텍스트 문자의 문자열을 분해하고 구조를 생성하는 일련의 과정
- **렌더링**
    - HTML, CSS, JS로 작성된 문서를 `파싱`하여 브라우저에 시각적으로 출력하는 것
<br>

### HTML 파싱과 DOM 생성 과정
---
![Image](https://github.com/user-attachments/assets/eecb8281-daa7-42fe-b260-405ff4ba5a49)
- 사용자가 위 URL을 입력하면, 오른쪽 그림과 같이 렌더링이 진행된다.
- 큰 흐름을 살펴보면 서버에 HTML 파일을 요청하여 응답 받고, CSS 파일을 요청하여 응답 받고, JS 파일을 요청하여 응답을 받는 과정을 거친다.
- 이때, 브라우저(클라이언트)의 요청에 의해 서버로부터 응답 받은 HTML문서는 `문자열로 이루어진 순수한 텍스트`일 뿐이므로 브라우저가 이를 이해하기 위해서 `번역`하는 과정이 필요하다!
    
    ```jsx
    <div><p>Hello</p></div> → DOM 트리로 변환
    
    - div
    - p
    - 텍스트 노드 "Hello"
    ```
<br>  

![Image](https://github.com/user-attachments/assets/e5c76ff9-850b-4c97-b945-499468120957)
- 위 그림은 브라우저가 응답 받은 HTML문서를 번역하는 과정을 나타내고 있다.
- 결과적으로 브라우저가 이해할 수 있는, `노드`들로 구성된 `트리` 형태의 자료구조를 `DOM(Document Object Model)`이라고 한다.
- 즉, `DOM은 HTML 문서를 파싱한 결과물`이다.
<br>

### CSS 파싱과 CSSOM 생성
---
![Image](https://github.com/user-attachments/assets/60329889-8183-4c83-96db-c2587726c7d4)
- 렌더링 엔진(내용 정보인 HTML, XML과 서식 정보인 CSS, XML 등을 읽어 들여 사람이 읽을 수 있는 문서로 표시하는 웹 브라우저의 핵심 기능을 담당하는 소프트웨어)은 `처음부터 한 줄씩 순차적으로 파싱`하며 `DOM을 생성`한다.

### 렌더 트리(Render Tree) 생성
---
![Image](https://github.com/user-attachments/assets/06a63791-324a-4965-a703-5fe7e8686997)
- DOM과 CSSOM이 모두 생성되었다면, 이 둘은 렌더링을 위해 `렌더 트리`로 결합된다.
- 렌더 트리는 `브라우저 화면에 보여지지 않는 것들은 포함하지 않는다.` 
ex) HTML meta 태그, CSS의 display: none 등
- 즉, 렌더 트리는 `브라우저 화면에 렌더링 되는 노드만으로 구성`된다.
- 이후 렌더 트리는 HTML 요소의 레이아웃(위치와 크기)을 계산하는 데 사용되며, 브라우저 화면에 픽셀을 렌더링하는 `페인팅 처리`에 입력된다.
<br>

### 브라우저 렌더링이 반복되는 경우
---
- 브라우저 렌더링은 `딱 한 번만 실행되는 것이 아니다.`
    1. 자바스크립트에 의해 노드가 추가 또는 삭제되는 경우
    2. 브라우저 창의 리사이징에 의한 뷰포트 크기가 변경되는 경우
    3. HTML 요소의 레이아웃에 변경을 발생시키는 width, height 등의 스타일이 변경되는 경우
- 위의 경우 반복해서 레이아웃 계산과 페인팅이 재차 실행되고, 이를 `리렌더링`이라고 한다.
- 리렌더링은 성능에 `악영향`을 주므로 리렌더링이 자주 일어나지 않도록 자바스크립트로 `과하게 노드를 제어`하거나, `display: none; 스타일을 주었다가 다시 보여주는` 등의 남용을 주의해야 한다.
<br>

### 자바스크립트 파싱과 실행
---
- DOM은 HTML의 구조 및 정보뿐만 아니라 HTML 요소를 제어할 수 있는 `DOM API`를 제공한다.
- 즉, DOM API는 DOM의 각 노드와 상호작용하기 위한 인터페이스, 또는 HTML을 JS에서 제어하기 위한 명령들의 집합이며, 대표적으로 자바스크립트에서 자주 사용되는 `document.querySelector()` 등을 예로 들 수 있다.
- 이러한 DOM API를 사용하면 `이미 생성된 DOM을 동적으로 조작`할 수 있다.
- HTML문서의 파싱을 진행하다가 \<script> 태그를 만나면 DOM 파싱은 일시 중단된다.
- JS는 DOM을 조작하거나 페이지 스타일을 변경할 수 있기 때문에 HTML 파싱을 일시 중단하고 JS를 다운로드 및 실행한다.
- JS가 실행되고 나면 일시 중단됐던 HTML 파싱이 다시 이어지게 된다.
- \<script> 태그에 `defer`나 `asnyc`속성을 추가하면 파싱 중단을 방지할 수 있다.
    - **defer:** 스크립트는 HTML 파싱이 끝난 후에 실행된다.
    - **async:** 스크립트는 비동기로 다운로드 되고, 다운로드가 끝나면 즉시 실행되며 HTML 파싱을 병렬로 계속 진행된다.
- CSSOM은 렌더링 엔진이 만들었다면, \<script> 태그 내의 JS 코드를 파싱할 때는 `렌더링 엔진이 자바스크립트 엔진에게 제어권을 넘긴다.`
<br>

💡
**동기와 비동기의 의미**
---
- **동기적(synchronous):** 어떤 작업을 요청했을 때, 그 작업이 `종료될 때까지 기다린 후` 다음 작업을 수행하는 방식
- **비동기적(asynchronous):** 어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다리지 않고 다른 작업을 하고 있다가 요청했던 작업이 종료되면 그에 대한 추가 작업을 수행하는 방식

![Image](https://github.com/user-attachments/assets/f013c39d-c7a1-48ca-b201-4791277841b4)

- 파싱 과정 중 JS 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우, DOM이나 CSSOM이 변경된다.
- 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되며 `리렌더링`되는데, 이를 `리플로우(reflow, 레이아웃 계산을 다시 해주는 것)`와 `리페인트(repaint, 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것)`라고 한다.

![Image](https://github.com/user-attachments/assets/340dfd1e-1482-4e2b-90d6-3addb6aaa6f6)

- 위 그림은 \<script> 태그의 위치에 따른 비교이다.
- 태그가 \<head>에 있는 경우와 \<body>의 마지막 부분에 있는 경우에 따라 HTML의 파싱이 블로킹되어 DOM 생성이 지연될 수 있으므로 \<script> 태그의 위치는 매우 중요한 의미를 가진다.
- `예를 들어, JS 코드 내에서 아직 파싱되지 않은 DOM 객체에 접근하려는 경우 에러가 발생할 수 있다.`
- 따라서 body 요소 가장 아래에 \<script> 태그를 명시하는 것이 상대적으로 더 권장된다.
- DOM이 완성된 후, JS가 DOM을 조작하니 요소를 찾지 못하는 오류도 없고, HTML 블로킹이 없어 페이지 로딩 시간이 단축되기 때문이다.
<br>

### 요약
---
![Image](https://github.com/user-attachments/assets/e3f11a05-edcf-47fa-9eb0-e7222800257a)
- **브라우저 렌더링 순서**
    1. 사용자가 브라우저로 웹 사이트에 접속하면 브러우저가 IP 파악
    2. 브라우저가 서버에게 HTTP Request
    3. 서버가 브라우저에게 HTTP Response
    4. HTML을 파싱하여 DOM Tree 생성
        - 이 과정에서 CSSOM Tree, AST 생성
    5. DOM + CSSOM → 렌더 트리 생성
    6. 렌더 트리에 있는 노드를 배치(Layout)
    7. 렌더 트리에 있는 노드의 UI를 그림(Paint)
    8. 렌더 트리에 있는 노드를 순서대로 구성(Composition)
    9. 사용자에게 결과 화면을 출력
<br>

### 참고
---
- https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work
- https://oliviakim.tistory.com/80
