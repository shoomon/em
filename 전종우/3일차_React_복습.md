### 이벤트 핸들링(Event Handling)
---
- 웹 내부에서 발생하는 사용자의 행동이 발생했을 때 그것을 처리하는 것
- ex) 버튼 클릭, 메세지 입력, 스크롤 발생 => 경고창 노출
- **합성 이벤트(Synthetic Base Event)**
    - 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태
<br>

### Cross Browsing Issue
---
- 브라우저별 스펙이 달라 발생하는 문제
<br>

### State
---
- 현재 가지고 있는 형태나 모양을 정의
- 변화할 수 있는 동적인 값
- State의 값에 따라 렌더링 되는 UI가 결정된다.
- react는 state 값이 변화했을 때만 리렌더링 되기 때문에 useState가 아닌 변수의 변화에 대해서는 화면에 반영되지 않는다.
- **react에서 리렌더링이 일어나는 경우 3가지**
    1. 자신이 관리하는 state의 값이 변경되는 경우
    2. 제공받은 props의 값이 변경되는 경우
    3. 부모 컴포넌트가 리렌더링 되면서 자식 컴포넌트가 리렌더링 되는 경우
<br>

### React Hooks
---
- 클래스 컴포넌트의 기능을 함수 컴포넌트에서도 이용할 수 있도록 도와주는 메서드로 이름 앞에 use가 붙는다.
- `함수 컴포넌트 내부`에서만 호출 가능
- `커스텀 훅`을 만드는 것도 가능
<br>

### React Life Cycle
---
- Mount → Update → UnMount
- **Mount**
    - 컴포넌트가 탄생하는 순간
    - 화면에 처음 렌더링 되는 순간을 의미
- **Update**
    - 컴포넌트가 다시 렌더링 되는 순간
    - 리렌더링 될 때를 의미
- **UnMount**
    - 컴포넌트가 화면에서 사라지는 순간
    - 렌더링에서 제외되는 순간을 의미
<br>

### useState
---
- State를 생성
- 컴포넌트 내부의 변수로 활용 가능
- 값이 변경되면 컴포넌트 리렌더링
<br>

### useRef
---
- Reference 객체를 생성
- 컴포넌트 내부의 변수로 활용 가능
- 어떤 경우에도 리렌더링을 유발하지 않음
- `그렇다면, useRef를 사용하지 않고 그냥 let으로 변수를 선언하고 사용하면 되지 않을까?`
    - 리액트의 특수한 변수(useState, useRef, ...)들은 컴포넌트가 리렌더링 된다고 해도 다시 리셋이 되지 않는데, let 변수 같은 경우에는 리렌더링이 될 때마다 초기화 되므로 값을 유지할 수 없다!!
- `그렇다면, 리렌더링 시 let 변수의 초기화 방지를 위해 let을 컴포넌트 외부(전역)에 선언하면 되지 않을까?`
    - 하나의 컴포넌트만 사용할 때는 가능하나, 동일한 컴포넌트를 2개 이상의 사용할 경우 해당 변수가 공유되므로 원하는 결과를 얻을 수 없을 것이다.
    - 또한, 리액트에서는 정말 특별한 경우가 아니라면 전역 변수의 사용을 권장하지 않는다.
<br>

### useEffect
---
- 리액트 컴포넌트의 `사이드 이펙트`를 제어하는 새로운 React Hook

**사이드 이펙트(Side Effect)**
- 리액트에서 사이드 이펙트란 부수적인 효과, 파생되는 효과 정도로 해석
- 리액트의 state는 비동기로 업데이트가 되기 때문에 변경된 state의 값을 바로 사용해서 무언가 부수적인 작업이 필요하다면, useEffect를 이용해야 한다.
<br>

### useReducer
---
- 컴포넌트 내부에 새로운 State를 생성하는 React Hook
- 모든 useState는 useReducer로 대체 가능
- `상태 관리 코드`를 `컴포넌트 외부`로 `분리`할 수 있음
- **useState를 사용하면?**
    - `컴포넌트 내부`에 상태 관리 코드를 작성해야 함
- **useReducer를 사용하면?**
    - `컴포넌트 외부`에 상태 관리 코드를 분리할 수 있음
    - 컴포넌트 내부에서는 State를 생성만 해놓고 실제로 이 State를 관리하는 코드들은 컴포넌트 외부에서 관리하도록 할 수 있음
<br>

### 최적화(Optimization)
---
- 웹 서비스의 성능을 개선하는 모든 행위를 일컫음
- 아주 단순한 것부터 아주 어려운 방법까지 매우 다양함
- **일반적인 웹 서비스 최적화 방법**
    - 서버의 응답 속도 개선
    - 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
    - 불필요한 네트워크 요청 줄임
    - ...
- **React App 내부의 최적화 방법**
    - 컴포넌트 내부의 불필요한 연산 방지
    - 컴포넌트 내부의 불필요한 함수 재생성 방지
    - 컴포넌트의 불필요한 리렌더링 방지
- **최적화 관련 참고**
    - 기능 구현을 먼저하고 최적화를 하자
    - 모든 컴포넌트를 최적화하는 것이 아니다, 유저의 행동에 따라 개수가 굉장히 많아질 수 있거나 함수를 많이 가지는 `무거운 컴포넌트에 대해서 최적화`를 수행하자.
<br>

### useMemo
---
- 메모이제이션 기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
<br>

### React.memo
---
- 컴포넌트를 인수로 받아, 최적화 된 컴포넌트로 만들어 반환
- 고차 컴포넌트 (HOC)
- ex) memo(TodoItem, (prevProps, curProps) => {
// 반환값에 따라 Props가 바뀌었는지 안바뀌었는지 판단
// true: Props가 바뀌지 않음 -> 리렌더링 X
// false: Props가 바뀜 -> 리렌더링 O
...
}
<br>

### useCallback
---
- React.memo 메서드는 현재 이 컴포넌트의 props가 바뀌었는지 안바뀌었는지에 대한 유무를 기본적으로 `얕은 비교(===)`로 판단하기 때문에 함수와 같은 객체 타입의 값을 props로 전달해 줄 때에는 제대로 된 최적화가 이루어지지 않을 수 있다.
- 따라서 memo의 두 번째 매개변수로 콜백 함수를 통해 이전 값과 현재 값이 바뀌었는지에 대한 처리가 필요했었다. 하지만 최적화를 위해 매번 모든 props에 대해 일일이 다 비교하도록 코드를 작성하는 것은 불편하고 유지보수가 어려울 것이다.
- 이럴 때는 `특정 함수가 애초에 재생성 되지 않도록 만들어주는 것`이 useCallback이라는 리액트 훅이다.
<br>

### context
---
- 컴포넌트 간의 데이터를 전달하는 또 다른 방법
- 기존의 props가 가지고 있던 단점을 해결할 수 있음
- props는 부모→자식으로만 데이터를 전달할 수 있었음
- 따라서 `손자로의 데이터 전달 시에는 중간 컴포넌트를 거쳐야하는 문제(Props Drilling)`가 있다.
- 데이터 보관소(객체)의 역할
- `createContext`, `useContext`를 이용
<br>

### 페이지 라우팅(Page Routing)
---
- 경로에 따라 알맞은 페이지를 렌더링하는 과정
- **MPA(Multi Page Application)**
    - 서버가 여러 개의 페이지를 가지고 있음
    - 많은 서비스가 사용하는 전통적인 방식
    - 상대적으로 페이지 이동이 매끄럽지 않고 비효율적임
    - 다수의 사용자 접속 시, 서버의 부하가 심해짐
    - `SSR(Server Side Rendering)` 방식을 사용
- **SPA(Single Page Application)**
    - React App이 채택한 방식
    - 페이지 이동이 매끄럽고 효율적임
    - 다수의 사용자가 접속해도 크게 상관 없음
    - `CSR(Client Side Rendering)` 방식을 사용
- `Routes` 컴포넌트 안에는 `Route` 컴포넌트만 추가할 수 있다.
- Routes 컴포넌트 밖에 배치된 요소들은 페이지 라우팅과는 관련 없이 모든 페이지에 다 동일하게 렌더링 된다.
- **CSR 방식의 페이지 이동 방법**
    - `컴포넌트`가 `모두 마운트 된 이후`에만 `nav 함수가 정상적으로 동작`한다.
    1. Link 컴포넌트 사용
        
        ```jsx
        <Link to={"/new"}>New</Link>
        ```
        
    2. 스크립트 내에서 useNavigate 훅 사용
        
        ```jsx
        const nav = useNavigate();
        
        const onClickButton = () => {
        nav("/new");
        };
        ```
<br>        

### 동적 경로(Dynamic Segments)
---
- 동적인 데이터를 포함하고 있는 경로
- ex) ~/product/1, ~/product/2, ~/search?q=검색어
- **URL Parameter 방식**
    - / 뒤에 아이템의 id를 명시
    - 아이템의 id 등 변경되지 않는 값을 주소로 명시하기 위해 사용 됨
    - `useParams` 훅을 통해 파라미터를 가져올 수 있다.
- **Query String 방식**
    - ? 뒤에 변수명과 값 명시
    - 검색어 등의 자주 변경되는 값을 주소로 명시하기 위해 사용 됨
    - `useSearchParams` 훅을 통해 파라미터를 가져올 수 있다.
<br>

### 웹 스토리지(Web Storage)
---
- 웹 브라우저 내장 DB
- 웹 브라우저에 기본적으로 내장되어 있는 데이터베이스
- 별도의 프로그램 설치 필요 X, 라이브러리 설치 필요 X
- 그냥 `자바스크립트 내장함수`만으로 접근 가능
- **값을 저장:** localStorage.setItem(key, value);
- **값을 꺼냄:** localStorage.getItem(key);
- **SessionStorage**
    - `브라우저 탭 별`로 데이터를 보관
    - 탭이 종료되기 전에는 데이터 유지(새로고침)
    - 탭이 종료되거나 꺼지면 데이터 삭제
- **LocalStorage**
    - `사이트 주소별`로 데이터 보관
    - 사용자가 직접 삭제하기 전까지 데이터 보관
<br>

### 배포
---
- vercel