### 교차 타입과 합집합 타입
---
- **& 교차 타입(Intersection Type)**
    - 두 개 이상의 타입을 **모두 만족하는 타입**을 정의할 때 사용.
    - 객체 타입에서는 **모든 속성을 합친다**.
    - 공통된 속성이 있다면, **더 좁은 타입**이 적용됨.
    - **예제**
        
        ```tsx
        type A = { name: string };
        type B = { age: number };
        
        type Person = A & B;  // { name: string; age: number }
        
        const person: Person = {
          name: "John",
          age: 30,
        };
        
        ```
        
    - **속성이 겹칠 경우**
        
        ```tsx
        type X = { value: string };
        type Y = { value: number };
        
        type XY = X & Y;  // { value: never }
        ```
        

- **| 합집합 타입(Union Type)**
    - 두 개 이상의 타입 중 **하나만 만족해도 되는 타입**을 정의할 때 사용.
    - **예제**
        
        ```tsx
        type A = { name: string };
        type B = { age: number };
        
        type Person = A | B;  
        
        const p1: Person = { name: "Alice" }; // ✅ OK
        const p2: Person = { age: 30 };       // ✅ OK
        const p3: Person = { name: "Bob", age: 25 }; // ✅ OK
        
        ```
        
    - `A | B`는 `{ name: string }` 또는 `{ age: number }` 또는 `{ name: string, age: number }`가 될 수 있다.
<br>

### 타입 추론
---
- **infer**
    - infer 키워드는 조건부 타입(extends) 내부에서 타입을 추론할 때 사용한다.
    - 주로 `제네릭`과 함께 사용된다.
    - **예제**
        
        ```tsx
        type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
        
        type Func = () => string;
        type Result = GetReturnType<Func>;  // Result = string
        
        ```
        
    
### 유틸리티 타입
---
- 타입스크립트에는 여러 유틸리티 타입을 제공되며, 이를 활용하면 타입 변환이 편리해 진다.
- **Partial<T>**
    - 모든 속성을 `선택적`으로 변경
    - **예제**
        
        ```tsx
        type User = {
          id: number;
          name: string;
        };
        
        type PartialUser = Partial<User>;
        
        const user: PartialUser = { name: "Alice" };  // ✅ OK
        ```
        
- **Required<T>**
    - 모든 속성을 `필수`로 변경
    - **예제**
        
        ```tsx
        type User = {
          id?: number;
          name?: string;
        };
        
        type RequiredUser = Required<User>;
        
        const user: RequiredUser = { id: 1, name: "Bob" };  // ✅ OK
        
        ```
        
- **Readonly<T>**
    - 모든 속성을 `읽기 전용(readonly)`으로 변경
    - **예제**
        
        ```tsx
        type User = {
          id: number;
          name: string;
        };
        
        type ReadonlyUser = Readonly<User>;
        
        const user: ReadonlyUser = { id: 1, name: "Alice" };
        user.name = "Bob";
        ```
        
- **Pick<T, K>**
    - 특정 속성만 선택하여 새로운 타입 생성
    - **예제**
        
        ```tsx
        type User = {
          id: number;
          name: string;
          email: string;
        };
        
        type UserNameOnly = Pick<User, "name">;  // { name: string }
        
        ```
        
- **Omit<T, K>**
    - 특정 속성을 제외한 나머지 타입을 생성
    - **예제**
        
        ```tsx
        type User = {
          id: number;
          name: string;
          email: string;
        };
        
        type UserWithoutEmail = Omit<User, "email">;  // { id: number; name: string }
        
        ```
        
- **Extract<T, U>**
    - T에서 U에 해당하는 타입만 추출
    - **예제**
        
        ```tsx
        type T = "a" | "b" | "c";
        type U = "a" | "c" | "d";
        
        type Excluded = Exclude<T, U>;  // "b"
        ```
        
- **Record<K, T>**
    - K를 키로, T를 값으로 가지는 객체 타입 생성
    - **예제**
        
        ```tsx
        type UserRoles = Record<"admin" | "user", number>;
        // { admin: number, user: number }
        
        const roles: UserRoles = {
          admin: 1,
          user: 2,
        };
        ```
        
- **NonNullable<T>**
    - `null`과 `undefined`를 **제외한 타입 반환**.
    - **예제**
        
        ```tsx
        type T = string | null | undefined;
        type NonNullableT = NonNullable<T>;  // string
        ```
        
- **ReturnType<T>**
    - 함수의 **반환 타입**을 추출
    - **예제**
        
        ```tsx
        type Func = () => number;
        type Result = ReturnType<Func>;  // number
        ```
